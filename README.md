### **README - 分布式点函数 (DPF) 实现**

---

#### **项目简介**

本项目实现了一个简单的 **分布式点函数（Distributed Point Function, DPF）**，该函数允许通过密钥共享的方式安全地计算一个点函数 f 
α,β
​
 (x)。点函数在触发点 α 返回值 \( \beta \)，在其他点返回 0。

该实现基于 **AES** 作为伪随机函数（PRF）构造密钥共享，并利用异或（XOR）操作确保在触发点 \( \alpha \) 合并共享值后返回正确的结果。

---

#### **功能概述**

1. **DPF 密钥生成（`dpf_gen`）**：
   - 根据给定的触发点 α 和返回值 \( \beta \)，生成两方的密钥共享 `share0` 和 `share1`。
   - 使用伪随机函数生成伪随机共享值，并调整触发点 \( \alpha \) 的共享值，确保合并结果为 \( \beta \)。

2. **DPF 评估（`dpf_eval`）**：
   - 使用共享密钥在查询点 \( x \) 处评估密钥共享，返回对应共享值。

3. **共享合并**：
   - 将两方的共享值通过异或操作合并，得到点函数在查询点处的最终结果。

---

#### **运行环境**

- **Python**：3.7 或更高版本
- **依赖库**：
  - `cryptography`：用于实现 AES 加密

---

#### **文件说明**

- **`prf` 函数**：实现基于 AES 的伪随机函数，用于生成共享值。
- **`int_to_bytes` 函数**：将整数转换为指定长度的字节串，便于与共享值对齐。
- **`dpf_gen` 函数**：生成分布式点函数的密钥共享。
- **`dpf_eval` 函数**：评估分布式点函数，返回共享值。
- **主程序**：示例演示如何使用上述函数生成密钥共享并评估点函数。

---

#### **使用方法**

1. **设置触发点和返回值**：
   在主程序中，设置触发点 \( \alpha \) 和返回值 \( \beta \)，例如：
   ```python
   alpha, beta = 3, 10  # 设置触发点 alpha 和返回值 beta
   size = 10  # 输入域的大小
   ```

2. **调用密钥生成函数**：
   ```python
   share0, share1 = dpf_gen(alpha, beta, size)
   ```

3. **评估共享值**：
   对触发点 \( \alpha \) 使用 `dpf_eval` 函数分别评估方 0 和方 1 的共享值：
   ```python
   share0_eval = dpf_eval(share0, alpha)
   share1_eval = dpf_eval(share1, alpha)
   ```

4. **合并共享值**：
   将两方共享值异或合并，得到最终的结果：
   ```python
   merged_result = int.from_bytes(share0_eval, 'big') ^ int.from_bytes(share1_eval, 'big')
   result = merged_result & 0xFF  # 取最低 8 位
   print(f"Result at alpha: {result}")  # 输出: beta 值
   ```

---

#### **函数详细说明**

1. **`prf` 函数**
   - 使用 AES 加密实现伪随机函数。
   - 输入一个密钥 `key` 和一个点索引 `input`，返回一个固定长度的伪随机字节串（8 字节）。

2. **`int_to_bytes` 函数**
   - 将整数值转换为固定长度的字节串，便于与 PRF 输出的共享值进行异或操作。

3. **`dpf_gen` 函数**
   - 生成两方的密钥共享 `share0` 和 `share1`：
     - 非触发点的共享值通过 PRF 生成。
     - 触发点 \( \alpha \) 的共享值通过调整确保合并后返回 \( \beta \)。
   - 使用 XOR 操作修改 `share0[alpha]`：
     \[
     \text{share0[alpha]} = \beta \oplus \text{share1[alpha]}
     \]

4. **`dpf_eval` 函数**
   - 根据密钥共享 `share` 和查询点 \( x \)，返回该点处的共享值。

---

#### **示例输入与输出**

1. **输入参数**：
   - \( \alpha = 3 \)：触发点
   - \( \beta = 10 \)：触发点的返回值
   - 输入域大小 \( \text{size} = 10 \)

2. **输出结果**：
   ```
   Result at alpha: 10
   ```

---

#### **原理解析**

1. **密钥共享生成**：
   - 使用 PRF 为每个点生成伪随机共享值。
   - 通过调整触发点 \( \alpha \) 的共享值，确保两方共享合并后返回 \( \beta \)。

2. **共享合并**：
   - 将两个共享值进行异或操作，通过异或的结合律和自反性确保触发点处的合并结果为 \( \beta \)。

---

#### **注意事项**

1. **输入域大小**：需要确保输入域大小 \( \text{size} \) 足够覆盖触发点 \( \alpha \)。
2. **字节串长度**：确保 `beta` 转换为字节串后长度与 PRF 输出一致。
3. **依赖库**：需要安装 `cryptography` 库。可以使用以下命令安装：
   ```bash
   pip install cryptography
   ```

---

#### **扩展与改进**

- **多方扩展**：目前实现的是两方共享，未来可以扩展为多方共享。
- **性能优化**：针对大规模输入域可以优化 PRF 的计算效率。

---

#### **联系作者**

如有问题或建议，请随时联系开发者！

