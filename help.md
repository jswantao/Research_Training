好的，我会对这篇论文的结构进行整理，并分析每个模块的作用以及它们的相互关系。此外，我将提供代码复现的指导，以便实现一个本地运行的在线加密时空关键词检索服务。这个服务可以用于如地图软件的查询功能等场景。

我会整理论文内容并制定代码实现方案后再与您分享，稍等片刻。

 **论文结构与模块分析：** 《Beyond Result Verification: Efficient Privacy-Preserving Spatial Keyword Query With Suppressed Leakage》论文围绕在加密空间关键字查询中实现高效检索与结果验证展开，其结构包括引言、问题模型与挑战、方案设计各模块、安全分析、性能评估和结论等部分。引言部分阐述了布尔范围查询（Boolean Range Query, BRQ）的背景与现有方案的不足，指出大多数已有方案难以在抑制访问模式和搜索模式泄漏的同时实现高效检索和轻量级结果验证 ([
&#34;Beyond result verification: Efficient privacy-preserving spatial keywo&#34; by Qiuyun TONG, Xinghua LI et al.
](https://ink.library.smu.edu.sg/sis_research/8657#:~:text=applications,which%20protects%20the%20access%20and))。为此，论文提出了一种新的隐私保护BRQ方案，并概述了其核心模块： **查询转换模块** （将空间范围查询转化为多关键字查询）、 **隐私查询执行模块** （实现模糊查询以隐藏访问/搜索模式）、 **结果验证模块** （提供轻量级的结果完整性验证）。各模块各司其职又相互衔接，共同实现安全高效的加密查询。下面对各模块的作用及相互关系进行详细分析。

* **查询转换模块（空间范围转多关键字）** ：首先，论文将BRQ问题转化为多关键字搜索问题 ([
  &#34;Beyond result verification: Efficient privacy-preserving spatial keywo&#34; by Qiuyun TONG, Xinghua LI et al.
  ](https://ink.library.smu.edu.sg/sis_research/8657#:~:text=search%20pattern%20leakage,which%20protects%20the%20access%20and))。具体而言，空间范围条件通过格雷码（Gray Code）编码来表示，文本关键字集合通过布隆过滤器表示，使得“查询矩形范围 + 若干关键词”的条件被统一转换为一组需要同时满足的关键字。每条数据对象预先存储其空间位置的格雷码向量以及包含其文本关键字的布隆过滤器 ([[PDF] Privacy-preserving Boolean range query over encrypted spatial data](https://ink.library.smu.edu.sg/cgi/viewcontent.cgi?article=6926&context=sis_research#:~:text=data%20ink,As%20for))。查询时，用户将查询的地理范围划分为若干格雷码区域（确保这些编码覆盖查询范围），将查询关键词加入布隆过滤器，以得到 **查询token集合** 。这样，一个原本包含空间约束和多个关键词的查询被表示为多个必须匹配的token（类似多关键字查询中的所有关键词），统一交由后续的加密查询模块处理。该模块的作用在于： **将空间和文本条件离散化、符号化** ，方便利用现有的加密多关键字查询技术，并为隐藏查询模式打下基础。
* **隐私查询执行模块（模糊多关键字查询）** ：经过转换得到查询token集合后，云服务器需要在加密数据中检索包含所有这些token的记录。论文采用了分布式点函数（Distributed Point Function, DPF）和基于伪随机置换的布谷鸟哈希（PRP-based Cuckoo Hashing）相结合的方法，实现高效的**模糊（Oblivious）多关键字查询** ([
  &#34;Beyond result verification: Efficient privacy-preserving spatial keywo&#34; by Qiuyun TONG, Xinghua LI et al.
  ](https://ink.library.smu.edu.sg/sis_research/8657#:~:text=convert%20BRQ%20into%20multi,support%20lightweight%20and%20oblivious%20result))。具体来说，数据拥有者使用布谷鸟哈希构建索引，将每个数据对象按照其格雷码和关键词布隆过滤器映射到哈希表的位置，并通过伪随机置换扰乱位置顺序，以防止泄漏模式信息。查询阶段，用户针对每一个查询token利用DPF生成加密查询讯息（例如查询相关哈希表位置的令牌），提交给云端。DPF可以将一次点查询分拆为由两台非协作服务器执行的子查询，从而在保证服务器看不到查询具体内容的同时检索出对应项。通过DPF和索引的结合，服务器在不知晓实际查询token的情况下，对索引执行查询并找出同时满足所有token的数据记录集合。这个模块的作用在于： **执行真正的数据检索且不暴露查询内容和访问模式** 。借助DPF的加密查询，服务器无法得知查询涉及的具体关键字或空间位置；通过PRP扰乱后的布谷鸟哈希索引，重复查询也不会暴露固定的访问位置模式，从而抑制了访问模式和搜索模式泄漏 ([
  &#34;Beyond result verification: Efficient privacy-preserving spatial keywo&#34; by Qiuyun TONG, Xinghua LI et al.
  ](https://ink.library.smu.edu.sg/sis_research/8657#:~:text=convert%20BRQ%20into%20multi,support%20lightweight%20and%20oblivious%20result))。查询转换模块提供的token集合作为本模块的输入条件，本模块输出查询匹配的加密记录集合，并将有关验证的信息一并处理，供下一个模块使用。
* **结果验证模块（完整性验证）** ：针对云服务器可能恶意丢弃、伪造结果的情况，论文设计了轻量级的 **结果完整性验证机制** 。该模块利用了 **聚合消息鉴别码（MAC）** 、**密钥哈希MAC**以及**可异或同态的伪随机函数**等密码技术，结合前述的模糊查询过程，实现了不泄漏额外信息的验证方案 ([
  &#34;Beyond result verification: Efficient privacy-preserving spatial keywo&#34; by Qiuyun TONG, Xinghua LI et al.
  ](https://ink.library.smu.edu.sg/sis_research/8657#:~:text=point%20function%20and%20PRP,the%20size%20of%20the%20outsourced))。其基本思路是：数据拥有者为每条记录预先计算一个认证标签（例如 keyed-hash MAC），当服务器检索出满足查询的记录集合时，可对这些标签进行聚合运算（例如异或累加）得到一个紧凑的证明值。查询用户收到结果后，同样基于查询得到的记录重新计算并聚合标签，对比服务器提供的证明值是否一致 ([
  &#34;Beyond result verification: Efficient privacy-preserving spatial keywo&#34; by Qiuyun TONG, Xinghua LI et al.
  ](https://ink.library.smu.edu.sg/sis_research/8657#:~:text=search%20patterns,the%20size%20of%20the%20outsourced))。由于所用的PRF支持异或同态性，多个标签的异或结果相当于这些记录整体的一个验证标识，且证明大小与数据集规模无关，仅与结果集大小或固定参数相关 ([
  &#34;Beyond result verification: Efficient privacy-preserving spatial keywo&#34; by Qiuyun TONG, Xinghua LI et al.
  ](https://ink.library.smu.edu.sg/sis_research/8657#:~:text=verification%20based%20on%20oblivious%20query%2C,analysis%20and%20extensive%20experiments%20demonstrate))。这样，用户无需下载所有非结果数据也能检查服务器是否遗漏或篡改结果。结果验证模块的作用是： **保证查询结果的完整性和正确性** ，即使云服务器不可信，用户也能通过验证机制发现不一致之处。它与查询执行模块配合：查询执行模块在返回记录的同时计算验证证明，验证模块使用这些信息与用户持有的密钥进行校验，从而将检索得到的加密结果转换为用户可信任的明文结果输出。
* **安全分析与性能评估** ：论文在安全性分析部分严格证明了方案满足自适应安全，能够在强威胁模型下保护数据的机密性和查询的隐私（包括访问模式和搜索模式）不泄露 ([
  &#34;Beyond result verification: Efficient privacy-preserving spatial keywo&#34; by Qiuyun TONG, Xinghua LI et al.
  ](https://ink.library.smu.edu.sg/sis_research/8657#:~:text=integrity%20with%20a%20proof%20whose,secure%20and%20efficient%20for%20practical))。同时，通过理论分析和实验评估，论文展示了该方案在实际数据集上的高效性，包括查询耗时、通信开销以及验证开销均在可接受范围，优于许多现有方案。在性能评估模块中，各子模块的效率瓶颈也得到讨论，例如DPF查询在不同参数下的耗时、布谷鸟哈希装载因子对查询性能的影响等，从而验证了方案设计中各模块组合的实用性。

综上，论文的结构清晰地由问题定义逐步过渡到解决方案的各功能模块，再到安全与性能的验证。各模块间相互配合：**查询转换模块**提供了统一的查询表示供加密检索使用，**隐私查询执行模块**在此基础上完成实际的数据检索且保证查询过程不泄露隐私，**结果验证模块**对执行模块产出的结果进行校验确保完整性。通过这些模块的串联，论文最终实现了一个在云环境下**高效、隐私保护且可验证**的空间关键词查询方案 ([
&#34;Beyond result verification: Efficient privacy-preserving spatial keywo&#34; by Qiuyun TONG, Xinghua LI et al.
](https://ink.library.smu.edu.sg/sis_research/8657#:~:text=applications,which%20protects%20the%20access%20and)) ([
&#34;Beyond result verification: Efficient privacy-preserving spatial keywo&#34; by Qiuyun TONG, Xinghua LI et al.
](https://ink.library.smu.edu.sg/sis_research/8657#:~:text=point%20function%20and%20PRP,the%20size%20of%20the%20outsourced))。

**代码复现方案：**下面提供一个从零开始实现论文方法，并逐步扩展为在线加密时空（空间和时间）关键词检索服务的代码复现方案。该方案涵盖数据结构设计、查询处理流程、隐私保护机制和结果验证等方面，并通过示例数据进行测试验证每个步骤。

1. **数据结构选择与初始化：**首先选择合适的编程语言（例如Python或C++）及所需的密码学库（如支持哈希、AES对称加密、MAC生成等）。定义基础数据结构用于表示空间数据对象，例如创建一个类 `DataObject`包含属性：坐标（latitude, longitude等）、关键词集合，以及附加的加密字段和验证标签。接着，确定如何编码空间位置和关键词：采用**格雷码** （Gray code）来编码空间坐标，便于后续处理范围查询；采用 **布隆过滤器** （Bloom filter）表示每个对象的关键词集合，布隆过滤器的长度和哈希函数个数可根据数据规模调整，以控制误判率。 ([[PDF] Privacy-preserving Boolean range query over encrypted spatial data](https://ink.library.smu.edu.sg/cgi/viewcontent.cgi?article=6926&context=sis_research#:~:text=data%20ink,As%20for)) 初始化阶段需生成所需的密码学密钥，包括：用于数据内容加密的对称密钥K_d，用于结果标签生成/验证的MAC密钥K_m，以及用于伪随机置换(PRP)的密钥K_p 等。这些密钥在真实应用中应安全保管：K_d和K_m由数据拥有者/查询用户持有，K_p可由数据拥有者用于构建索引时使用（服务器不应获知PRP密钥）。数据结构初始化的最后一步是确定索引存储方案大小参数，例如布谷鸟哈希表的大小（根据数据量和装载因子选择），以及每条记录可能占用的哈希槽数量等，为后续索引构建做好准备。
2. **索引构建（数据预处理）：**由数据拥有者在本地对所有数据对象构建加密索引。具体过程如下：遍历每条数据记录，计算其坐标的格雷码表示（例如将二维坐标映射为一维格雷码值，或分别计算经度、纬度的格雷码并组合），计算其关键词集合的布隆过滤器位列表示。然后，为该记录生成一个用于结果验证的标签，例如用MAC密钥K_m对记录的主要内容计算一个消息鉴别码MAC(value)并附加在记录上。随后，将记录插入**布谷鸟哈希表**索引：以记录的格雷码值或其哈希、以及可能结合关键词布隆过滤器作为键，通过两套独立的哈希函数计算两个候选位置，将记录存入相应槽位。如果发生冲突则按照布谷鸟哈希算法逐出已有记录重新安置，直到插入完成。插入过程中应用伪随机置换(PRP)：例如对每个计算出的哈希值，再用密钥K_p执行一次伪随机置换函数，以打乱原始哈希映射，使服务器难以通过观察访问模式推断数据分布。最终，得到存储在服务器端的加密索引结构：每个哈希槽存放若干信息——可能包括记录ID、加密的记录内容（使用密钥K_d加密）、对应的关键词布隆过滤器、验证标签MAC等。若论文方案采用了两台非合作服务器（two-server）模型以利用DPF性质，则可以将构建好的索引结构在两台服务器之间分片保存（例如将布谷鸟哈希表随机拆分为两部分，各存一半），或者让两台服务器各持有一份完整索引但通过不同密钥扰动，以便后续查询时分别处理各自的份额。从代码实现角度，索引构建模块需实现：格雷码编码函数、布隆过滤器生成与更新函数、布谷鸟哈希插入算法（支持PRP扰动），以及将最终索引序列化存储的功能。完成索引构建后，服务器持有加密索引，但由于使用了格雷码和布隆过滤器表示数据，并经过加密和随机置换处理，服务器无法直接解读其中明文信息，保证了数据静态存储的保密性。
3. **查询处理流程实现（客户端）：**查询由用户客户端发起并主要在本地构造加密查询请求，然后提交给云服务器处理。实现步骤如下：
   * **查询编码：**客户端输入查询参数，包括空间范围（例如矩形区域的经纬度下限和上限）和关键词列表。首先使用与索引相同的方法对查询范围进行格雷码编码。范围查询可通过格雷码前缀来表示：实现一个函数，将二维查询范围转化为覆盖该范围的最小格雷码区间集合。例如，对于给定经度区间和纬度区间，可枚举所有满足范围的格雷码前缀或利用空间填充曲线（如Z-curve）将2D范围映射为若干1D格雷码区段。这样得到的若干格雷码值或前缀集合代表查询的空间条件。接着，将查询关键词列表插入一个与数据索引相同配置的布隆过滤器，得到查询关键词的位阵列表示（或者直接使用关键词集合本身作为条件亦可）。 **最终，查询的条件被表示为一组“必须满足的标识token”** ：包括若干空间格雷码token和若干关键词token。这个token集合即对应多关键字查询中的多个查询项，只有同时具备这些token的记录才算匹配。
   * **查询加密：**为了在提交给服务器时不暴露这些token本身，客户端需要将查询token加密或变换为模糊查询形式。根据论文方案，使用**分布式点函数(DPF)**生成查询令牌 ([
     &#34;Beyond result verification: Efficient privacy-preserving spatial keywo&#34; by Qiuyun TONG, Xinghua LI et al.
     ](https://ink.library.smu.edu.sg/sis_research/8657#:~:text=convert%20BRQ%20into%20multi,support%20lightweight%20and%20oblivious%20result))。如果采用two-server模型，DPF可将一个查询token对应的索引访问编码成两个子密钥(sk1, sk2)：当分别输入给两台服务器时，各自执行计算可产生一个指标，组合后相当于服务器在不知道实际查询token的情况下检索了与token相关的位置。客户端针对查询token集合中的每一个token，都生成相应的DPF密钥对(sk1, sk2)。如果查询需要匹配所有token，可采取两种实现方式：（1）**交互式多关键字查询：**逐个token查询获取部分结果并在客户端求交集；（2） **单轮多关键字查询：**构造一个能同时编码多个token条件的复杂DPF查询。但实现上更可行的是前者——客户端对每个token执行一次DPF查询请求，服务器返回候选匹配集合，客户端取各集合交集得到最终结果。为了减少往返次数，也可以将多个token的查询批量封装发送。对于每个token的DPF查询：如果是two-server，每台服务器收到对应的子密钥；若是单服务器环境，可以模拟DPF效果——例如采用私人信息检索(PIR)技术或者让服务器执行盲态线性扫描匹配。无论哪种方式，实现过程中需要调用密码学库函数生成DPF密钥（或PIR查询），并组织查询请求的数据结构。此步骤的输出是发送给服务器的加密查询请求，其中不包含明文的空间或关键词信息，从而保证**查询的搜索模式不泄漏** 。
4. **查询处理流程实现（服务器）：**服务器端接收到用户的加密查询请求后，执行检索并返回结果。实现细节如下：
   * **DPF查询计算：**对于two-server方案，两个服务器各自接收DPF子密钥sk1和sk2，在本地加载索引结构。根据DPF协议，每台服务器对索引执行对应的操作（通常是对某伪随机函数序列的部分计算），得到该查询token对应的临时结果。例如，每个服务器可能得到一个与索引长度相同的向量，其中除了一处对应token匹配的位置外其余均为零值（由于DPF生成的是指示函数）。两台服务器将各自结果向量按元素异或，可得到一个“命中向量”，标识出哪些记录含有该查询token。对于单服务器模式，若无法直接利用DPF，可选择让服务器遍历索引中所有记录，检查其是否包含查询token（例如检查记录的格雷码是否属于查询格雷码集合，且布隆过滤器是否包含查询关键词集合所有位）。虽然单服务器遍历在性能和泄漏上不如DPF方案优良，但可用于功能验证。无论哪种实现，服务器此阶段需要将匹配查询条件的记录标识提取出来。
   * **多token匹配与结果提取：**若采用客户端交互逐token查询，服务器会针对每个token返回一个匹配记录ID列表或命中向量。客户端据此求交集后，将最终匹配的记录ID请求对应服务器提取记录内容。如果采用单轮方案，服务器可以直接在一次查询中应用所有token条件过滤出最终结果记录。实际编码中，为方便起见可以将**多关键字查询处理看作对布隆过滤器的匹配** ：例如将查询布隆过滤器发送给服务器，令服务器对每条记录的布隆过滤器做按位与运算检查是否涵盖查询关键词位，同时检查格雷码是否匹配查询区域，从而一次性筛选出结果集。选定匹配的记录后，服务器从索引中提取这些记录的加密内容和验证标签。**访问模式保护：**由于索引采用了布谷鸟哈希和PRP扰乱，服务器对数据的存取序号与实际数据关联是伪随机的，再加上DPF/PIR的作用，服务器无法通过这一次访问推断出查询条件或数据模式 ([
     &#34;Beyond result verification: Efficient privacy-preserving spatial keywo&#34; by Qiuyun TONG, Xinghua LI et al.
     ](https://ink.library.smu.edu.sg/sis_research/8657#:~:text=convert%20BRQ%20into%20multi,support%20lightweight%20and%20oblivious%20result))。服务器将提取出的加密记录集合暂存，并进入结果验证信息计算过程。
   * **结果验证证明生成：**按照论文方案，服务器需为结果集计算一个证明值，以供用户检验完整性。实现时，服务器可以将所有结果记录的MAC标签进行聚合。例如，假设每条记录有一个128-bit的MAC标签 `t_i`，服务器将所有命中记录的 `t_i`逐位异或，得到聚合值 `P = t_1 ⊕ t_2 ⊕ ... ⊕ t_n`。如果论文采用更复杂的验证（如分层MAC或累加器），则按其定义计算。与此同时，服务器可能还利用用户查询本身的某些加密信息参与计算证明（论文提到利用“oblivious query”本身的一些性质） ([
     &#34;Beyond result verification: Efficient privacy-preserving spatial keywo&#34; by Qiuyun TONG, Xinghua LI et al.
     ](https://ink.library.smu.edu.sg/sis_research/8657#:~:text=search%20patterns,the%20size%20of%20the%20outsourced))。代码实现上，可以简单地按上述方式聚合MAC获得证明值 `P`。最后，服务器将**查询结果集（加密的数据）**以及**证明值**一起打包返回给查询用户。值得注意的是，证明值的大小通常是恒定的（例如固定长度字符串），不随结果集大小线性增长，从而保持通信开销的小巧 ([
     &#34;Beyond result verification: Efficient privacy-preserving spatial keywo&#34; by Qiuyun TONG, Xinghua LI et al.
     ](https://ink.library.smu.edu.sg/sis_research/8657#:~:text=verification%20based%20on%20oblivious%20query%2C,analysis%20and%20extensive%20experiments%20demonstrate))。
5. **结果解密与验证（客户端）：**客户端在收到服务器返回的结果后，执行解密和验证，确保结果正确无误。具体实现如下：
   * **结果解密：**使用数据加密密钥K_d，对每条返回记录的加密内容进行解密，得到明文的记录信息（包括原始的坐标和关键词等）。然后可以本地验证这些记录是否确实满足查询条件（例如检查坐标是否在查询范围内，关键词是否包含查询的所有词），以获得对结果正确性的直观确认。
   * **逐条完整性验证：**对于每条返回记录，利用MAC密钥K_m重新计算其完整性标签，并与记录随附的标签比对，确认记录在存储和传输过程中未被篡改。如果标签不匹配，应当立即拒绝结果并记录错误。这一步保证**结果内容的真实性** 。
   * **结果集完整性验证：**聚合验证是本方案的创新之处。客户端对收到的所有记录的MAC标签执行与服务器相同的聚合操作（例如异或所有 `t_i`得到 `P_user`)，然后将此聚合值与服务器返回的证明值 `P`进行比较 ([
     &#34;Beyond result verification: Efficient privacy-preserving spatial keywo&#34; by Qiuyun TONG, Xinghua LI et al.
     ](https://ink.library.smu.edu.sg/sis_research/8657#:~:text=search%20patterns,the%20size%20of%20the%20outsourced))。如果二者一致，则高概率表明服务器没有漏掉任何满足查询的记录也没有夹杂伪造记录；若不一致，说明结果可能不完整或不正确，用户可判定服务器不诚信。由于用户并不预先知道查询该得到哪些记录，所以这种验证利用了用户持有的密钥和聚合函数的同态性来间接检查**结果集合的完整** 。代码实现上，只需几行对二进制标签进行异或的操作即完成验证，计算复杂度随结果数量线性增长，但因为证明值长度固定且结果数通常远小于数据总量，所以开销很小。通过这一模块，用户最终得到 **经过验证的查询结果** ：若验证通过，可放心使用解密后的结果；若未通过，则舍弃结果并可追究服务器责任。
6. **示例数据及测试：**构造简明的示例来验证实现的正确性和完整性。首先准备一小片空间数据，例如模拟若干地理坐标点及其关联的关键词列表（可假定为城市中的兴趣点POI，每个POI包含位置和标签词）。手动在明文域确定一个测试查询（如查询某一区域内包含关键词{"公园", "餐厅"}的所有POI），列出预期满足条件的POI清单。然后在本地按照上述步骤运行代码：
   * **数据加载与索引构建测试：**调用索引构建模块，将示例POI数据建立加密索引。检查哈希表填充情况，确保所有数据成功插入。可以打印部分布隆过滤器或格雷码编码结果以人工核对正确性。
   * **查询编码与加密测试：**对设定的测试查询，运行查询编码模块，输出生成的格雷码区间和查询布隆过滤器，核对这些应覆盖手工指定的查询范围和关键词。然后运行查询加密模块，生成DPF密钥或模拟的查询令牌，验证其长度和格式符合预期。
   * **服务器检索模拟测试：**调用服务器查询处理代码，给定上述查询令牌，检索索引得到结果记录。对于测试目的，可令服务器也解密这些记录，打印匹配结果，与预期列表比对，确认检索准确无误。同时计算返回的聚合证明值。
   * **客户端验证测试：**客户端对服务器返回的结果执行解密，并逐条验证内容正确性。然后计算聚合标签值，与服务器提供值比较，应当匹配。将验证结果（通过或不通过）输出。如果要测试验证模块对恶意行为的检测能力，可模拟服务器**遗漏**一条实际匹配的记录，仅返回不完整结果和错误证明值，看看客户端验证是否能够发现不一致（预期应检测失败）。通过上述测试步骤，逐步调试确保每个模块功能正确，并在整体上实现了预期的隐私保护查询效果。
   * **性能与参数测试：**在小数据集上测量每次查询的处理时间、通信量，以及随着数据量增长趋势。由于示例规模有限，性能数据仅作功能验证参考；在实际部署前，可进一步在较大合成数据集上测试性能并调整参数（如布隆过滤器大小、哈希表装载率）以优化效率。
7. **扩展部署为在线服务：**在本地验证功能正确后，可将系统扩展为真正的在线加密时空关键词检索服务：
   * **服务器端部署：**选择一个服务器环境（例如云主机或本地服务器），部署索引构建和查询处理代码。可以使用Web框架提供HTTP接口，例如提供“/build_index”接口供数据拥有者上传数据文件触发服务器端索引构建；提供“/query”接口供用户提交加密查询令牌获取结果。服务器应常驻运行，预先加载加密索引到内存（或高效的数据库中）以响应查询请求。在two-server模型下，需要部署两台独立服务器，索引构建时将数据划分存储，两服务器都提供查询接口且在后端协同处理DPF查询（例如通过各自返回部分结果给客户端，由客户端合并）。
   * **客户端应用：**开发客户端应用或脚本，封装查询流程。客户端首先从数据拥有者处获得必要的密钥材料（K_d, K_m 等），然后提供友好的界面让用户输入查询区域（可通过地图选取多边形范围）和关键词。客户端调用本地实现将用户输入转换为加密查询请求（与本地测试流程相同），通过HTTP请求发送给云服务器的查询接口。收到响应后，客户端执行结果解密和验证，将最终明文结果呈现给用户。例如，可将结果标注在地图上或以列表显示。同时，在界面上提示验证状态（“结果已验证可信”或警告用户可能不完整）。
   * **安全与密钥管理：**在服务化过程中，要特别注意密钥管理和通信安全。客户端与服务器的通信应通过TLS加密传输。客户端的密钥不应泄露给服务器，服务器执行查询不需要知道K_d或K_m，只需用其存储的索引和提供的令牌即可。对于two-server方案，客户端需要将不同的查询子令牌发送到不同服务器（可以在应用中并行发送），并从各服务器获得部分结果。在非交互式证明情况下，可能需要让两服务器直接交换部分计算结果（这可通过让它们互联或通过客户端中转来实现）。在代码实现中，可简化为顺序请求两个服务器并在客户端合并。
   * **支持时空扩展：**如果需要支持时空查询，时间维度的处理可类似空间维度：例如将时间范围也编码为某种区间token，纳入查询token集合。可在代码中增加对时间字段的布尔范围查询支持，将“时间”看作第三维度处理。这样，系统即可支持“时空关键词”综合查询，仍符合论文思想。
   * **测试与迭代部署：**最后，在在线环境使用真实或大型模拟数据进行测试。模拟多用户并发查询、数据动态更新（如插入删除）对系统的影响，逐步完善代码。例如，评估索引重建或增量更新的代价，考虑缓存热点查询结果等优化。通过迭代开发和测试，最终形成一个稳定的在线服务，实现论文中的全部功能，在实际场景中提供安全可靠的加密时空关键词检索。
